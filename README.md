设计模式：（在软件设计过程中哪个地方进行使用，并且解决了什么问题）
处理软件设计中反复出现的问题

可扩展性 复用性 规范性 稳定性 可维护性 代码的可读性 灵活性  可靠性（高内聚低耦合）

遵守一套公共的设计模式

面向对象（oo） => 功能模块（设计模式 + 算法【树结结构】） => 框架 （使用多种设计模式） => 架构（服务器集群）

设计模式七大原则，23中设计模式


单一职责原则（对于类的设计每一个单一功能的类只处理一类问题）
	举例说明（交通工具不同的运行方式）
	方案一：对类进行拆分（写法比较松散，花销改动很大）
	方案二： 增加方法（但是没有完全遵守单一职责原则。只是在方法级别进行遵守。在类级别没有遵守）

	特点：
	1.降低类的复杂度
	2.提高可读性，可维护性
	3.降低变更风险
	4.通常情况下我们应该遵守，但不排除例外，只有代码逻辑足够简单，才允许在代码和类级别违反单一原则，在方法级别保持原则

接口隔离（segregation）
	最小接口依赖规则，只与自己相关的依赖建立相关的关系，不应该依赖于它不需要的接口
	都原有接口进行拆分，拆分成多个接口

依赖倒转（作用： 降低了客户和模块之间的耦合度）是实现开闭原则的重要途径之一
	原则：  接口传递，
		 构造方法传递
		 setter方式传递
	定义： 高层模块不应该依赖于底层模块，两者都应该依赖于抽象而不应该依赖于细节，面向接口编程，不要面向实现编程

里氏替换 （跟继承相关）里氏替换原则是实现开闭原则的重要方式之一（避免不要重写父类的方法）
	定义： 所有引用基类的地方都必须能透明的使用其子类的对象
	// export class LisA {
//   intergerSub(intA: number, intB: number): number{
//     return intA - intB;
//   }
// }
// export class LisB extends LisA {
//   // 重写A类中的方法
//   intergerSub(intA: number, intB: number): number{
//     return intA + intB;
//   }
//   intergerMulti(intA: number, intB: number): number{
//     return intA * intB;
//   }
// }
 * 上面的写法会造成方法调用结果出现混淆，因为在子类的继承中重写了父类的方法，所以导致可能会造成在方法调用的时候分辨不清
 * 通过向上提取更简单的基类 让父子类共同继承该基类
 *
 * 如果还想让原来的子类调用原来父类中的方法，那么可以使用聚合组合的方式实现，注入

开闭原则（用抽象构建框架，用实现扩展细节）
	定义： 当应用的需求发生改变时，在不修改软件实体的原代码或者二进制代码的前提下，可以扩展模块的功能，能够满足新的需求
	
	作用： （对于软件测试）
	只需要对扩展代码进行测试，原有代码可以正常运行
		（提高代码的可复用性）
	粒度越小，被复用的可能性就越大，原子和抽象编程
		（提高可维护性）
	稳定性和延续性强，易于扩展和维护


迪米特法则【最少知道原则】（只与直接朋友联系，陌生类不要以局部变量的形式出现）
	直接朋友： 两个类之间存在依赖耦合关系，一个类在另一个类中的表现形式为成员变量，方法参数和方法返回值的类称之为直接朋友
	定义： 两个软件实体之间通过第三方转发调用，降低类之间的耦合度，提高模块的相对独立性
	个人理解：
		模块之间只需要实现自己的功能定义，如果两个实体之间需要配合使用，那么在不兼容的情况下用第三方接口完成转发（类似于适配器模式）



合成复用原则
	原则： 在软件进行复用的情况下，首先考虑通过组合聚合的方式进行关联实现，其次才是继承关系来实现
	如果要使用继承关系，则必须严格遵守里氏替换原则， 合成复用原则和里氏替换原则相辅相成，两者都是开闭原则的实现规范
	
	
	继承复用和组合复用：
		组合复用： 将已有对象纳入新对象当中，并且可以增加自己额外的功能（组合复用的优点）
		1.维持了类的封装性，不会像继承复用把父类的实现都暴露给子类
		2.新旧类之间的耦合度降低
		3.复用的灵活性更高

七大原则总结：
	1.开闭原则是总纲，告诉我们对外要扩展开放，对修改关闭
	2.里氏替换原则则是说不要破环继承体系，通过向上抽取更简单的基类
	3.依赖倒转原则则是要面向接口编程
	4.单一职责则是实现类的功能要尽可能的单一
	5.接口隔离原则则是在接口实现的时候要按照最小接口标准去实现
	6.迪米特法则则是说降低耦合度
	7.合成复用的原则则是优先考虑使用组合和聚合的方式，其次是继承
	
	
	
23种设计模式
	创建型：	单例模式（singleton）、原型模式（Prototype）、工厂方法模式（FactoryMethod）、抽象工厂模式（AbstractFactory）、建造者模式（Constructor）
	
单例模式： 
	在软件应用当中，通常是为了节省内存资源，保证数据的一致性，对默写特定要求只能创建一个实例
	优点： 
		1.单例模式保证内存中只有一个实例，减少内存开销
		2.避免对资源的多重占用
		3.可以设置全局的访问点，可以优化和共享资源的访问
	缺点：
		1.单例模式一般没有接口，扩展困难，如果需要扩展就需要波及原来的代码，，违背了开闭原则
		2.不利于并发测试，调试过程中单例中的代码没有执行完，就不能模拟生成一个新的对象
		3.单例模式的代码通常只定义一个类，如果设计不合理，很容易违背单一职责原则
		
原型模式
	避免使用构造方法创建多个相同或者相似的实例，使用原型模式则能解决
	优点：
		1.java自带原型模型基于二进制流的复制，在性能上比new一个性能更优（原型模型就指定了创建对象的种类）
		2.可以使用深度克隆方式保存对象的状态
	缺点：
		1.需要每一个类都配置一个clone方法
		2.clone方法位于类的内部，对已有的类进行改造时，就需要修改原来代码，违背了开闭原则
		3.对象多层嵌用时，实现深度克隆，实现起来会比较复杂
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
